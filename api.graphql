schema {
  query: query_root
  mutation: mutation_root
  subscription: Subscription
}

type AuthPayload {
  user: User
}

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

input LoginInput {
  email: String!
  password: String!
}

type Organization {
  id: ID!
  name: String!
}

input RegisterInput {
  email: String!
  password: String!
}

enum Role {
  ADMIN
  EDITOR
  CUSTOMER
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

type Subscription {
  """
  fetch data from the table: "author_course"
  """
  author_course(
    """distinct select on columns"""
    distinct_on: [author_course_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [author_course_order_by!]

    """filter the rows returned"""
    where: author_course_bool_exp
  ): [author_course!]!

  """
  fetch aggregated fields from the table: "author_course"
  """
  author_course_aggregate(
    """distinct select on columns"""
    distinct_on: [author_course_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [author_course_order_by!]

    """filter the rows returned"""
    where: author_course_bool_exp
  ): author_course_aggregate!

  """fetch data from the table: "author_course" using primary key columns"""
  author_course_by_pk(id: uuid!): author_course

  """
  fetch data from the table: "authors"
  """
  authors(
    """distinct select on columns"""
    distinct_on: [authors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authors_order_by!]

    """filter the rows returned"""
    where: authors_bool_exp
  ): [authors!]!

  """
  fetch aggregated fields from the table: "authors"
  """
  authors_aggregate(
    """distinct select on columns"""
    distinct_on: [authors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authors_order_by!]

    """filter the rows returned"""
    where: authors_bool_exp
  ): authors_aggregate!

  """fetch data from the table: "authors" using primary key columns"""
  authors_by_pk(id: uuid!): authors

  """
  fetch data from the table: "categories"
  """
  categories(
    """distinct select on columns"""
    distinct_on: [categories_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [categories_order_by!]

    """filter the rows returned"""
    where: categories_bool_exp
  ): [categories!]!

  """
  fetch aggregated fields from the table: "categories"
  """
  categories_aggregate(
    """distinct select on columns"""
    distinct_on: [categories_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [categories_order_by!]

    """filter the rows returned"""
    where: categories_bool_exp
  ): categories_aggregate!

  """fetch data from the table: "categories" using primary key columns"""
  categories_by_pk(id: uuid!): categories

  """
  fetch data from the table: "course_module_user"
  """
  course_module_user(
    """distinct select on columns"""
    distinct_on: [course_module_user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [course_module_user_order_by!]

    """filter the rows returned"""
    where: course_module_user_bool_exp
  ): [course_module_user!]!

  """
  fetch aggregated fields from the table: "course_module_user"
  """
  course_module_user_aggregate(
    """distinct select on columns"""
    distinct_on: [course_module_user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [course_module_user_order_by!]

    """filter the rows returned"""
    where: course_module_user_bool_exp
  ): course_module_user_aggregate!

  """
  fetch data from the table: "course_module_user" using primary key columns
  """
  course_module_user_by_pk(id: uuid!): course_module_user

  """
  fetch data from the table: "course_user"
  """
  course_user(
    """distinct select on columns"""
    distinct_on: [course_user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [course_user_order_by!]

    """filter the rows returned"""
    where: course_user_bool_exp
  ): [course_user!]!

  """
  fetch aggregated fields from the table: "course_user"
  """
  course_user_aggregate(
    """distinct select on columns"""
    distinct_on: [course_user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [course_user_order_by!]

    """filter the rows returned"""
    where: course_user_bool_exp
  ): course_user_aggregate!

  """fetch data from the table: "course_user" using primary key columns"""
  course_user_by_pk(id: uuid!): course_user

  """An array relationship"""
  courses(
    """distinct select on columns"""
    distinct_on: [courses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [courses_order_by!]

    """filter the rows returned"""
    where: courses_bool_exp
  ): [courses!]!

  """An aggregate relationship"""
  courses_aggregate(
    """distinct select on columns"""
    distinct_on: [courses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [courses_order_by!]

    """filter the rows returned"""
    where: courses_bool_exp
  ): courses_aggregate!

  """fetch data from the table: "courses" using primary key columns"""
  courses_by_pk(id: uuid!): courses

  """
  fetch data from the table: "courses_learning_outcomes"
  """
  courses_learning_outcomes(
    """distinct select on columns"""
    distinct_on: [courses_learning_outcomes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [courses_learning_outcomes_order_by!]

    """filter the rows returned"""
    where: courses_learning_outcomes_bool_exp
  ): [courses_learning_outcomes!]!

  """
  fetch aggregated fields from the table: "courses_learning_outcomes"
  """
  courses_learning_outcomes_aggregate(
    """distinct select on columns"""
    distinct_on: [courses_learning_outcomes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [courses_learning_outcomes_order_by!]

    """filter the rows returned"""
    where: courses_learning_outcomes_bool_exp
  ): courses_learning_outcomes_aggregate!

  """
  fetch data from the table: "courses_learning_outcomes" using primary key columns
  """
  courses_learning_outcomes_by_pk(id: uuid!): courses_learning_outcomes

  """
  fetch data from the table: "courses_modules"
  """
  courses_modules(
    """distinct select on columns"""
    distinct_on: [courses_modules_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [courses_modules_order_by!]

    """filter the rows returned"""
    where: courses_modules_bool_exp
  ): [courses_modules!]!

  """
  fetch aggregated fields from the table: "courses_modules"
  """
  courses_modules_aggregate(
    """distinct select on columns"""
    distinct_on: [courses_modules_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [courses_modules_order_by!]

    """filter the rows returned"""
    where: courses_modules_bool_exp
  ): courses_modules_aggregate!

  """fetch data from the table: "courses_modules" using primary key columns"""
  courses_modules_by_pk(id: uuid!): courses_modules

  """
  fetch data from the table: "organizations"
  """
  organizations(
    """distinct select on columns"""
    distinct_on: [organizations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organizations_order_by!]

    """filter the rows returned"""
    where: organizations_bool_exp
  ): [organizations!]!

  """
  fetch aggregated fields from the table: "organizations"
  """
  organizations_aggregate(
    """distinct select on columns"""
    distinct_on: [organizations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organizations_order_by!]

    """filter the rows returned"""
    where: organizations_bool_exp
  ): organizations_aggregate!

  """fetch data from the table: "organizations" using primary key columns"""
  organizations_by_pk(id: uuid!): organizations

  """
  fetch data from the table: "sectors"
  """
  sectors(
    """distinct select on columns"""
    distinct_on: [sectors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sectors_order_by!]

    """filter the rows returned"""
    where: sectors_bool_exp
  ): [sectors!]!

  """
  fetch aggregated fields from the table: "sectors"
  """
  sectors_aggregate(
    """distinct select on columns"""
    distinct_on: [sectors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sectors_order_by!]

    """filter the rows returned"""
    where: sectors_bool_exp
  ): sectors_aggregate!

  """fetch data from the table: "sectors" using primary key columns"""
  sectors_by_pk(id: uuid!): sectors

  """An array relationship"""
  subcategories(
    """distinct select on columns"""
    distinct_on: [subcategories_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subcategories_order_by!]

    """filter the rows returned"""
    where: subcategories_bool_exp
  ): [subcategories!]!

  """An aggregate relationship"""
  subcategories_aggregate(
    """distinct select on columns"""
    distinct_on: [subcategories_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subcategories_order_by!]

    """filter the rows returned"""
    where: subcategories_bool_exp
  ): subcategories_aggregate!

  """fetch data from the table: "subcategories" using primary key columns"""
  subcategories_by_pk(id: uuid!): subcategories

  """An array relationship"""
  users(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """An aggregate relationship"""
  users_aggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!

  """fetch data from the table: "users" using primary key columns"""
  users_by_pk(id: uuid!): users
}

type User {
  id: ID!
  email: String!
  password: String!
  role: Role!
  organization: Organization
}

"""
columns and relationships of "author_course"
"""
type author_course {
  """An object relationship"""
  author: authors!
  author_id: uuid!

  """An object relationship"""
  course: courses!
  course_id: uuid!
  created_at: timestamptz!
  id: uuid!
  updated_at: timestamptz!
}

"""
aggregated selection of "author_course"
"""
type author_course_aggregate {
  aggregate: author_course_aggregate_fields
  nodes: [author_course!]!
}

"""
aggregate fields of "author_course"
"""
type author_course_aggregate_fields {
  count(columns: [author_course_select_column!], distinct: Boolean): Int!
  max: author_course_max_fields
  min: author_course_min_fields
}

"""
order by aggregate values of table "author_course"
"""
input author_course_aggregate_order_by {
  count: order_by
  max: author_course_max_order_by
  min: author_course_min_order_by
}

"""
input type for inserting array relation for remote table "author_course"
"""
input author_course_arr_rel_insert_input {
  data: [author_course_insert_input!]!

  """on conflict condition"""
  on_conflict: author_course_on_conflict
}

"""
Boolean expression to filter rows from the table "author_course". All fields are combined with a logical 'AND'.
"""
input author_course_bool_exp {
  _and: [author_course_bool_exp!]
  _not: author_course_bool_exp
  _or: [author_course_bool_exp!]
  author: authors_bool_exp
  author_id: uuid_comparison_exp
  course: courses_bool_exp
  course_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "author_course"
"""
enum author_course_constraint {
  """unique or primary key constraint"""
  author_course_pkey
}

"""
input type for inserting data into table "author_course"
"""
input author_course_insert_input {
  author: authors_obj_rel_insert_input
  author_id: uuid
  course: courses_obj_rel_insert_input
  course_id: uuid
  created_at: timestamptz
  id: uuid
  updated_at: timestamptz
}

"""aggregate max on columns"""
type author_course_max_fields {
  author_id: uuid
  course_id: uuid
  created_at: timestamptz
  id: uuid
  updated_at: timestamptz
}

"""
order by max() on columns of table "author_course"
"""
input author_course_max_order_by {
  author_id: order_by
  course_id: order_by
  created_at: order_by
  id: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type author_course_min_fields {
  author_id: uuid
  course_id: uuid
  created_at: timestamptz
  id: uuid
  updated_at: timestamptz
}

"""
order by min() on columns of table "author_course"
"""
input author_course_min_order_by {
  author_id: order_by
  course_id: order_by
  created_at: order_by
  id: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "author_course"
"""
type author_course_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [author_course!]!
}

"""
on conflict condition type for table "author_course"
"""
input author_course_on_conflict {
  constraint: author_course_constraint!
  update_columns: [author_course_update_column!]!
  where: author_course_bool_exp
}

"""Ordering options when selecting data from "author_course"."""
input author_course_order_by {
  author: authors_order_by
  author_id: order_by
  course: courses_order_by
  course_id: order_by
  created_at: order_by
  id: order_by
  updated_at: order_by
}

"""primary key columns input for table: author_course"""
input author_course_pk_columns_input {
  id: uuid!
}

"""
select columns of table "author_course"
"""
enum author_course_select_column {
  """column name"""
  author_id

  """column name"""
  course_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  updated_at
}

"""
input type for updating data in table "author_course"
"""
input author_course_set_input {
  author_id: uuid
  course_id: uuid
  created_at: timestamptz
  id: uuid
  updated_at: timestamptz
}

"""
update columns of table "author_course"
"""
enum author_course_update_column {
  """column name"""
  author_id

  """column name"""
  course_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  updated_at
}

"""
columns and relationships of "authors"
"""
type authors {
  """An array relationship"""
  courses(
    """distinct select on columns"""
    distinct_on: [author_course_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [author_course_order_by!]

    """filter the rows returned"""
    where: author_course_bool_exp
  ): [author_course!]!

  """An aggregate relationship"""
  courses_aggregate(
    """distinct select on columns"""
    distinct_on: [author_course_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [author_course_order_by!]

    """filter the rows returned"""
    where: author_course_bool_exp
  ): author_course_aggregate!
  created_at: timestamptz
  description: String
  id: uuid!
  name: String!
  portrait_url: String
  qualifications: String
  updated_at: timestamptz
}

"""
aggregated selection of "authors"
"""
type authors_aggregate {
  aggregate: authors_aggregate_fields
  nodes: [authors!]!
}

"""
aggregate fields of "authors"
"""
type authors_aggregate_fields {
  count(columns: [authors_select_column!], distinct: Boolean): Int!
  max: authors_max_fields
  min: authors_min_fields
}

"""
Boolean expression to filter rows from the table "authors". All fields are combined with a logical 'AND'.
"""
input authors_bool_exp {
  _and: [authors_bool_exp!]
  _not: authors_bool_exp
  _or: [authors_bool_exp!]
  courses: author_course_bool_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  portrait_url: String_comparison_exp
  qualifications: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "authors"
"""
enum authors_constraint {
  """unique or primary key constraint"""
  authors_pkey
}

"""
input type for inserting data into table "authors"
"""
input authors_insert_input {
  courses: author_course_arr_rel_insert_input
  created_at: timestamptz
  description: String
  id: uuid
  name: String
  portrait_url: String
  qualifications: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type authors_max_fields {
  created_at: timestamptz
  description: String
  id: uuid
  name: String
  portrait_url: String
  qualifications: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type authors_min_fields {
  created_at: timestamptz
  description: String
  id: uuid
  name: String
  portrait_url: String
  qualifications: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "authors"
"""
type authors_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [authors!]!
}

"""
input type for inserting object relation for remote table "authors"
"""
input authors_obj_rel_insert_input {
  data: authors_insert_input!

  """on conflict condition"""
  on_conflict: authors_on_conflict
}

"""
on conflict condition type for table "authors"
"""
input authors_on_conflict {
  constraint: authors_constraint!
  update_columns: [authors_update_column!]!
  where: authors_bool_exp
}

"""Ordering options when selecting data from "authors"."""
input authors_order_by {
  courses_aggregate: author_course_aggregate_order_by
  created_at: order_by
  description: order_by
  id: order_by
  name: order_by
  portrait_url: order_by
  qualifications: order_by
  updated_at: order_by
}

"""primary key columns input for table: authors"""
input authors_pk_columns_input {
  id: uuid!
}

"""
select columns of table "authors"
"""
enum authors_select_column {
  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  name

  """column name"""
  portrait_url

  """column name"""
  qualifications

  """column name"""
  updated_at
}

"""
input type for updating data in table "authors"
"""
input authors_set_input {
  created_at: timestamptz
  description: String
  id: uuid
  name: String
  portrait_url: String
  qualifications: String
  updated_at: timestamptz
}

"""
update columns of table "authors"
"""
enum authors_update_column {
  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  name

  """column name"""
  portrait_url

  """column name"""
  qualifications

  """column name"""
  updated_at
}

scalar bpchar

"""
Boolean expression to compare columns of type "bpchar". All fields are combined with logical 'AND'.
"""
input bpchar_comparison_exp {
  _eq: bpchar
  _gt: bpchar
  _gte: bpchar

  """does the column match the given case-insensitive pattern"""
  _ilike: bpchar
  _in: [bpchar!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: bpchar
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: bpchar
  _lt: bpchar
  _lte: bpchar
  _neq: bpchar

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: bpchar
  _nin: [bpchar!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: bpchar

  """does the column NOT match the given pattern"""
  _nlike: bpchar

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: bpchar

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: bpchar

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: bpchar

  """does the column match the given SQL regular expression"""
  _similar: bpchar
}

"""
columns and relationships of "categories"
"""
type categories {
  """An array relationship"""
  courses(
    """distinct select on columns"""
    distinct_on: [courses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [courses_order_by!]

    """filter the rows returned"""
    where: courses_bool_exp
  ): [courses!]!

  """An aggregate relationship"""
  courses_aggregate(
    """distinct select on columns"""
    distinct_on: [courses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [courses_order_by!]

    """filter the rows returned"""
    where: courses_bool_exp
  ): courses_aggregate!
  created_at: timestamptz!
  id: uuid!
  name: String!

  """An array relationship"""
  subcategories(
    """distinct select on columns"""
    distinct_on: [subcategories_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subcategories_order_by!]

    """filter the rows returned"""
    where: subcategories_bool_exp
  ): [subcategories!]!

  """An aggregate relationship"""
  subcategories_aggregate(
    """distinct select on columns"""
    distinct_on: [subcategories_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subcategories_order_by!]

    """filter the rows returned"""
    where: subcategories_bool_exp
  ): subcategories_aggregate!
  updated_at: timestamptz!
}

"""
aggregated selection of "categories"
"""
type categories_aggregate {
  aggregate: categories_aggregate_fields
  nodes: [categories!]!
}

"""
aggregate fields of "categories"
"""
type categories_aggregate_fields {
  count(columns: [categories_select_column!], distinct: Boolean): Int!
  max: categories_max_fields
  min: categories_min_fields
}

"""
Boolean expression to filter rows from the table "categories". All fields are combined with a logical 'AND'.
"""
input categories_bool_exp {
  _and: [categories_bool_exp!]
  _not: categories_bool_exp
  _or: [categories_bool_exp!]
  courses: courses_bool_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  subcategories: subcategories_bool_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "categories"
"""
enum categories_constraint {
  """unique or primary key constraint"""
  categories_pkey
}

"""
input type for inserting data into table "categories"
"""
input categories_insert_input {
  courses: courses_arr_rel_insert_input
  created_at: timestamptz
  id: uuid
  name: String
  subcategories: subcategories_arr_rel_insert_input
  updated_at: timestamptz
}

"""aggregate max on columns"""
type categories_max_fields {
  created_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type categories_min_fields {
  created_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "categories"
"""
type categories_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [categories!]!
}

"""
input type for inserting object relation for remote table "categories"
"""
input categories_obj_rel_insert_input {
  data: categories_insert_input!

  """on conflict condition"""
  on_conflict: categories_on_conflict
}

"""
on conflict condition type for table "categories"
"""
input categories_on_conflict {
  constraint: categories_constraint!
  update_columns: [categories_update_column!]!
  where: categories_bool_exp
}

"""Ordering options when selecting data from "categories"."""
input categories_order_by {
  courses_aggregate: courses_aggregate_order_by
  created_at: order_by
  id: order_by
  name: order_by
  subcategories_aggregate: subcategories_aggregate_order_by
  updated_at: order_by
}

"""primary key columns input for table: categories"""
input categories_pk_columns_input {
  id: uuid!
}

"""
select columns of table "categories"
"""
enum categories_select_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

"""
input type for updating data in table "categories"
"""
input categories_set_input {
  created_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
}

"""
update columns of table "categories"
"""
enum categories_update_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

"""
Track the modules started/completed by a user


columns and relationships of "course_module_user"
"""
type course_module_user {
  course_module_id: uuid!
  created_at: timestamptz!
  id: uuid!

  """An object relationship"""
  module: courses_modules!
  progress: Int!
  updated_at: timestamptz!

  """An object relationship"""
  user: users!
  user_id: uuid!
}

"""
aggregated selection of "course_module_user"
"""
type course_module_user_aggregate {
  aggregate: course_module_user_aggregate_fields
  nodes: [course_module_user!]!
}

"""
aggregate fields of "course_module_user"
"""
type course_module_user_aggregate_fields {
  avg: course_module_user_avg_fields
  count(columns: [course_module_user_select_column!], distinct: Boolean): Int!
  max: course_module_user_max_fields
  min: course_module_user_min_fields
  stddev: course_module_user_stddev_fields
  stddev_pop: course_module_user_stddev_pop_fields
  stddev_samp: course_module_user_stddev_samp_fields
  sum: course_module_user_sum_fields
  var_pop: course_module_user_var_pop_fields
  var_samp: course_module_user_var_samp_fields
  variance: course_module_user_variance_fields
}

"""
order by aggregate values of table "course_module_user"
"""
input course_module_user_aggregate_order_by {
  avg: course_module_user_avg_order_by
  count: order_by
  max: course_module_user_max_order_by
  min: course_module_user_min_order_by
  stddev: course_module_user_stddev_order_by
  stddev_pop: course_module_user_stddev_pop_order_by
  stddev_samp: course_module_user_stddev_samp_order_by
  sum: course_module_user_sum_order_by
  var_pop: course_module_user_var_pop_order_by
  var_samp: course_module_user_var_samp_order_by
  variance: course_module_user_variance_order_by
}

"""
input type for inserting array relation for remote table "course_module_user"
"""
input course_module_user_arr_rel_insert_input {
  data: [course_module_user_insert_input!]!

  """on conflict condition"""
  on_conflict: course_module_user_on_conflict
}

"""aggregate avg on columns"""
type course_module_user_avg_fields {
  progress: Float
}

"""
order by avg() on columns of table "course_module_user"
"""
input course_module_user_avg_order_by {
  progress: order_by
}

"""
Boolean expression to filter rows from the table "course_module_user". All fields are combined with a logical 'AND'.
"""
input course_module_user_bool_exp {
  _and: [course_module_user_bool_exp!]
  _not: course_module_user_bool_exp
  _or: [course_module_user_bool_exp!]
  course_module_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  module: courses_modules_bool_exp
  progress: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: users_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "course_module_user"
"""
enum course_module_user_constraint {
  """unique or primary key constraint"""
  course_module_user_pkey
}

"""
input type for incrementing numeric columns in table "course_module_user"
"""
input course_module_user_inc_input {
  progress: Int
}

"""
input type for inserting data into table "course_module_user"
"""
input course_module_user_insert_input {
  course_module_id: uuid
  created_at: timestamptz
  id: uuid
  module: courses_modules_obj_rel_insert_input
  progress: Int
  updated_at: timestamptz
  user: users_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type course_module_user_max_fields {
  course_module_id: uuid
  created_at: timestamptz
  id: uuid
  progress: Int
  updated_at: timestamptz
  user_id: uuid
}

"""
order by max() on columns of table "course_module_user"
"""
input course_module_user_max_order_by {
  course_module_id: order_by
  created_at: order_by
  id: order_by
  progress: order_by
  updated_at: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type course_module_user_min_fields {
  course_module_id: uuid
  created_at: timestamptz
  id: uuid
  progress: Int
  updated_at: timestamptz
  user_id: uuid
}

"""
order by min() on columns of table "course_module_user"
"""
input course_module_user_min_order_by {
  course_module_id: order_by
  created_at: order_by
  id: order_by
  progress: order_by
  updated_at: order_by
  user_id: order_by
}

"""
response of any mutation on the table "course_module_user"
"""
type course_module_user_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [course_module_user!]!
}

"""
on conflict condition type for table "course_module_user"
"""
input course_module_user_on_conflict {
  constraint: course_module_user_constraint!
  update_columns: [course_module_user_update_column!]!
  where: course_module_user_bool_exp
}

"""Ordering options when selecting data from "course_module_user"."""
input course_module_user_order_by {
  course_module_id: order_by
  created_at: order_by
  id: order_by
  module: courses_modules_order_by
  progress: order_by
  updated_at: order_by
  user: users_order_by
  user_id: order_by
}

"""primary key columns input for table: course_module_user"""
input course_module_user_pk_columns_input {
  id: uuid!
}

"""
select columns of table "course_module_user"
"""
enum course_module_user_select_column {
  """column name"""
  course_module_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  progress

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "course_module_user"
"""
input course_module_user_set_input {
  course_module_id: uuid
  created_at: timestamptz
  id: uuid
  progress: Int
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate stddev on columns"""
type course_module_user_stddev_fields {
  progress: Float
}

"""
order by stddev() on columns of table "course_module_user"
"""
input course_module_user_stddev_order_by {
  progress: order_by
}

"""aggregate stddev_pop on columns"""
type course_module_user_stddev_pop_fields {
  progress: Float
}

"""
order by stddev_pop() on columns of table "course_module_user"
"""
input course_module_user_stddev_pop_order_by {
  progress: order_by
}

"""aggregate stddev_samp on columns"""
type course_module_user_stddev_samp_fields {
  progress: Float
}

"""
order by stddev_samp() on columns of table "course_module_user"
"""
input course_module_user_stddev_samp_order_by {
  progress: order_by
}

"""aggregate sum on columns"""
type course_module_user_sum_fields {
  progress: Int
}

"""
order by sum() on columns of table "course_module_user"
"""
input course_module_user_sum_order_by {
  progress: order_by
}

"""
update columns of table "course_module_user"
"""
enum course_module_user_update_column {
  """column name"""
  course_module_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  progress

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""aggregate var_pop on columns"""
type course_module_user_var_pop_fields {
  progress: Float
}

"""
order by var_pop() on columns of table "course_module_user"
"""
input course_module_user_var_pop_order_by {
  progress: order_by
}

"""aggregate var_samp on columns"""
type course_module_user_var_samp_fields {
  progress: Float
}

"""
order by var_samp() on columns of table "course_module_user"
"""
input course_module_user_var_samp_order_by {
  progress: order_by
}

"""aggregate variance on columns"""
type course_module_user_variance_fields {
  progress: Float
}

"""
order by variance() on columns of table "course_module_user"
"""
input course_module_user_variance_order_by {
  progress: order_by
}

"""
columns and relationships of "course_user"
"""
type course_user {
  completed: Boolean!

  """An object relationship"""
  course: courses!
  course_id: uuid!
  created_at: timestamptz!
  id: uuid!
  updated_at: timestamptz!

  """An object relationship"""
  user: users!
  user_id: uuid!
}

"""
aggregated selection of "course_user"
"""
type course_user_aggregate {
  aggregate: course_user_aggregate_fields
  nodes: [course_user!]!
}

"""
aggregate fields of "course_user"
"""
type course_user_aggregate_fields {
  count(columns: [course_user_select_column!], distinct: Boolean): Int!
  max: course_user_max_fields
  min: course_user_min_fields
}

"""
order by aggregate values of table "course_user"
"""
input course_user_aggregate_order_by {
  count: order_by
  max: course_user_max_order_by
  min: course_user_min_order_by
}

"""
input type for inserting array relation for remote table "course_user"
"""
input course_user_arr_rel_insert_input {
  data: [course_user_insert_input!]!

  """on conflict condition"""
  on_conflict: course_user_on_conflict
}

"""
Boolean expression to filter rows from the table "course_user". All fields are combined with a logical 'AND'.
"""
input course_user_bool_exp {
  _and: [course_user_bool_exp!]
  _not: course_user_bool_exp
  _or: [course_user_bool_exp!]
  completed: Boolean_comparison_exp
  course: courses_bool_exp
  course_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: users_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "course_user"
"""
enum course_user_constraint {
  """unique or primary key constraint"""
  course_user_pkey
}

"""
input type for inserting data into table "course_user"
"""
input course_user_insert_input {
  completed: Boolean
  course: courses_obj_rel_insert_input
  course_id: uuid
  created_at: timestamptz
  id: uuid
  updated_at: timestamptz
  user: users_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type course_user_max_fields {
  course_id: uuid
  created_at: timestamptz
  id: uuid
  updated_at: timestamptz
  user_id: uuid
}

"""
order by max() on columns of table "course_user"
"""
input course_user_max_order_by {
  course_id: order_by
  created_at: order_by
  id: order_by
  updated_at: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type course_user_min_fields {
  course_id: uuid
  created_at: timestamptz
  id: uuid
  updated_at: timestamptz
  user_id: uuid
}

"""
order by min() on columns of table "course_user"
"""
input course_user_min_order_by {
  course_id: order_by
  created_at: order_by
  id: order_by
  updated_at: order_by
  user_id: order_by
}

"""
response of any mutation on the table "course_user"
"""
type course_user_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [course_user!]!
}

"""
on conflict condition type for table "course_user"
"""
input course_user_on_conflict {
  constraint: course_user_constraint!
  update_columns: [course_user_update_column!]!
  where: course_user_bool_exp
}

"""Ordering options when selecting data from "course_user"."""
input course_user_order_by {
  completed: order_by
  course: courses_order_by
  course_id: order_by
  created_at: order_by
  id: order_by
  updated_at: order_by
  user: users_order_by
  user_id: order_by
}

"""primary key columns input for table: course_user"""
input course_user_pk_columns_input {
  id: uuid!
}

"""
select columns of table "course_user"
"""
enum course_user_select_column {
  """column name"""
  completed

  """column name"""
  course_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "course_user"
"""
input course_user_set_input {
  completed: Boolean
  course_id: uuid
  created_at: timestamptz
  id: uuid
  updated_at: timestamptz
  user_id: uuid
}

"""
update columns of table "course_user"
"""
enum course_user_update_column {
  """column name"""
  completed

  """column name"""
  course_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
columns and relationships of "courses"
"""
type courses {
  """An array relationship"""
  authors(
    """distinct select on columns"""
    distinct_on: [author_course_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [author_course_order_by!]

    """filter the rows returned"""
    where: author_course_bool_exp
  ): [author_course!]!

  """An aggregate relationship"""
  authors_aggregate(
    """distinct select on columns"""
    distinct_on: [author_course_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [author_course_order_by!]

    """filter the rows returned"""
    where: author_course_bool_exp
  ): author_course_aggregate!
  banner_url: String

  """An object relationship"""
  category: categories
  category_id: uuid
  created_at: timestamptz
  description: String
  difficulty: bpchar!
  id: uuid!

  """An array relationship"""
  learning_outcomes(
    """distinct select on columns"""
    distinct_on: [courses_learning_outcomes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [courses_learning_outcomes_order_by!]

    """filter the rows returned"""
    where: courses_learning_outcomes_bool_exp
  ): [courses_learning_outcomes!]!

  """An aggregate relationship"""
  learning_outcomes_aggregate(
    """distinct select on columns"""
    distinct_on: [courses_learning_outcomes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [courses_learning_outcomes_order_by!]

    """filter the rows returned"""
    where: courses_learning_outcomes_bool_exp
  ): courses_learning_outcomes_aggregate!

  """An array relationship"""
  modules(
    """distinct select on columns"""
    distinct_on: [courses_modules_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [courses_modules_order_by!]

    """filter the rows returned"""
    where: courses_modules_bool_exp
  ): [courses_modules!]!

  """An aggregate relationship"""
  modules_aggregate(
    """distinct select on columns"""
    distinct_on: [courses_modules_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [courses_modules_order_by!]

    """filter the rows returned"""
    where: courses_modules_bool_exp
  ): courses_modules_aggregate!

  """An object relationship"""
  sector: sectors
  sector_id: uuid

  """An object relationship"""
  subcategory: subcategories
  subcategory_id: uuid
  title: String!
  updated_at: timestamptz

  """An array relationship"""
  users(
    """distinct select on columns"""
    distinct_on: [course_user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [course_user_order_by!]

    """filter the rows returned"""
    where: course_user_bool_exp
  ): [course_user!]!

  """An aggregate relationship"""
  users_aggregate(
    """distinct select on columns"""
    distinct_on: [course_user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [course_user_order_by!]

    """filter the rows returned"""
    where: course_user_bool_exp
  ): course_user_aggregate!
}

"""
aggregated selection of "courses"
"""
type courses_aggregate {
  aggregate: courses_aggregate_fields
  nodes: [courses!]!
}

"""
aggregate fields of "courses"
"""
type courses_aggregate_fields {
  count(columns: [courses_select_column!], distinct: Boolean): Int!
  max: courses_max_fields
  min: courses_min_fields
}

"""
order by aggregate values of table "courses"
"""
input courses_aggregate_order_by {
  count: order_by
  max: courses_max_order_by
  min: courses_min_order_by
}

"""
input type for inserting array relation for remote table "courses"
"""
input courses_arr_rel_insert_input {
  data: [courses_insert_input!]!

  """on conflict condition"""
  on_conflict: courses_on_conflict
}

"""
Boolean expression to filter rows from the table "courses". All fields are combined with a logical 'AND'.
"""
input courses_bool_exp {
  _and: [courses_bool_exp!]
  _not: courses_bool_exp
  _or: [courses_bool_exp!]
  authors: author_course_bool_exp
  banner_url: String_comparison_exp
  category: categories_bool_exp
  category_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  difficulty: bpchar_comparison_exp
  id: uuid_comparison_exp
  learning_outcomes: courses_learning_outcomes_bool_exp
  modules: courses_modules_bool_exp
  sector: sectors_bool_exp
  sector_id: uuid_comparison_exp
  subcategory: subcategories_bool_exp
  subcategory_id: uuid_comparison_exp
  title: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  users: course_user_bool_exp
}

"""
unique or primary key constraints on table "courses"
"""
enum courses_constraint {
  """unique or primary key constraint"""
  courses_pkey
}

"""
input type for inserting data into table "courses"
"""
input courses_insert_input {
  authors: author_course_arr_rel_insert_input
  banner_url: String
  category: categories_obj_rel_insert_input
  category_id: uuid
  created_at: timestamptz
  description: String
  difficulty: bpchar
  id: uuid
  learning_outcomes: courses_learning_outcomes_arr_rel_insert_input
  modules: courses_modules_arr_rel_insert_input
  sector: sectors_obj_rel_insert_input
  sector_id: uuid
  subcategory: subcategories_obj_rel_insert_input
  subcategory_id: uuid
  title: String
  updated_at: timestamptz
  users: course_user_arr_rel_insert_input
}

"""
columns and relationships of "courses_learning_outcomes"
"""
type courses_learning_outcomes {
  """An object relationship"""
  course: courses!
  course_id: uuid!
  created_at: timestamptz
  description: String!
  icon_url: String
  id: uuid!
  updated_at: timestamptz
}

"""
aggregated selection of "courses_learning_outcomes"
"""
type courses_learning_outcomes_aggregate {
  aggregate: courses_learning_outcomes_aggregate_fields
  nodes: [courses_learning_outcomes!]!
}

"""
aggregate fields of "courses_learning_outcomes"
"""
type courses_learning_outcomes_aggregate_fields {
  count(columns: [courses_learning_outcomes_select_column!], distinct: Boolean): Int!
  max: courses_learning_outcomes_max_fields
  min: courses_learning_outcomes_min_fields
}

"""
order by aggregate values of table "courses_learning_outcomes"
"""
input courses_learning_outcomes_aggregate_order_by {
  count: order_by
  max: courses_learning_outcomes_max_order_by
  min: courses_learning_outcomes_min_order_by
}

"""
input type for inserting array relation for remote table "courses_learning_outcomes"
"""
input courses_learning_outcomes_arr_rel_insert_input {
  data: [courses_learning_outcomes_insert_input!]!

  """on conflict condition"""
  on_conflict: courses_learning_outcomes_on_conflict
}

"""
Boolean expression to filter rows from the table "courses_learning_outcomes". All fields are combined with a logical 'AND'.
"""
input courses_learning_outcomes_bool_exp {
  _and: [courses_learning_outcomes_bool_exp!]
  _not: courses_learning_outcomes_bool_exp
  _or: [courses_learning_outcomes_bool_exp!]
  course: courses_bool_exp
  course_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  icon_url: String_comparison_exp
  id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "courses_learning_outcomes"
"""
enum courses_learning_outcomes_constraint {
  """unique or primary key constraint"""
  courses_learning_outcomes_pkey
}

"""
input type for inserting data into table "courses_learning_outcomes"
"""
input courses_learning_outcomes_insert_input {
  course: courses_obj_rel_insert_input
  course_id: uuid
  created_at: timestamptz
  description: String
  icon_url: String
  id: uuid
  updated_at: timestamptz
}

"""aggregate max on columns"""
type courses_learning_outcomes_max_fields {
  course_id: uuid
  created_at: timestamptz
  description: String
  icon_url: String
  id: uuid
  updated_at: timestamptz
}

"""
order by max() on columns of table "courses_learning_outcomes"
"""
input courses_learning_outcomes_max_order_by {
  course_id: order_by
  created_at: order_by
  description: order_by
  icon_url: order_by
  id: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type courses_learning_outcomes_min_fields {
  course_id: uuid
  created_at: timestamptz
  description: String
  icon_url: String
  id: uuid
  updated_at: timestamptz
}

"""
order by min() on columns of table "courses_learning_outcomes"
"""
input courses_learning_outcomes_min_order_by {
  course_id: order_by
  created_at: order_by
  description: order_by
  icon_url: order_by
  id: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "courses_learning_outcomes"
"""
type courses_learning_outcomes_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [courses_learning_outcomes!]!
}

"""
on conflict condition type for table "courses_learning_outcomes"
"""
input courses_learning_outcomes_on_conflict {
  constraint: courses_learning_outcomes_constraint!
  update_columns: [courses_learning_outcomes_update_column!]!
  where: courses_learning_outcomes_bool_exp
}

"""Ordering options when selecting data from "courses_learning_outcomes"."""
input courses_learning_outcomes_order_by {
  course: courses_order_by
  course_id: order_by
  created_at: order_by
  description: order_by
  icon_url: order_by
  id: order_by
  updated_at: order_by
}

"""primary key columns input for table: courses_learning_outcomes"""
input courses_learning_outcomes_pk_columns_input {
  id: uuid!
}

"""
select columns of table "courses_learning_outcomes"
"""
enum courses_learning_outcomes_select_column {
  """column name"""
  course_id

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  icon_url

  """column name"""
  id

  """column name"""
  updated_at
}

"""
input type for updating data in table "courses_learning_outcomes"
"""
input courses_learning_outcomes_set_input {
  course_id: uuid
  created_at: timestamptz
  description: String
  icon_url: String
  id: uuid
  updated_at: timestamptz
}

"""
update columns of table "courses_learning_outcomes"
"""
enum courses_learning_outcomes_update_column {
  """column name"""
  course_id

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  icon_url

  """column name"""
  id

  """column name"""
  updated_at
}

"""aggregate max on columns"""
type courses_max_fields {
  banner_url: String
  category_id: uuid
  created_at: timestamptz
  description: String
  difficulty: bpchar
  id: uuid
  sector_id: uuid
  subcategory_id: uuid
  title: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "courses"
"""
input courses_max_order_by {
  banner_url: order_by
  category_id: order_by
  created_at: order_by
  description: order_by
  difficulty: order_by
  id: order_by
  sector_id: order_by
  subcategory_id: order_by
  title: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type courses_min_fields {
  banner_url: String
  category_id: uuid
  created_at: timestamptz
  description: String
  difficulty: bpchar
  id: uuid
  sector_id: uuid
  subcategory_id: uuid
  title: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "courses"
"""
input courses_min_order_by {
  banner_url: order_by
  category_id: order_by
  created_at: order_by
  description: order_by
  difficulty: order_by
  id: order_by
  sector_id: order_by
  subcategory_id: order_by
  title: order_by
  updated_at: order_by
}

"""
columns and relationships of "courses_modules"
"""
type courses_modules {
  """An object relationship"""
  course: courses!
  course_id: uuid!
  created_at: timestamptz
  description: String
  id: uuid!
  length: Int!
  thumbnail_url: String
  title: String!
  updated_at: timestamptz

  """An array relationship"""
  users(
    """distinct select on columns"""
    distinct_on: [course_module_user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [course_module_user_order_by!]

    """filter the rows returned"""
    where: course_module_user_bool_exp
  ): [course_module_user!]!

  """An aggregate relationship"""
  users_aggregate(
    """distinct select on columns"""
    distinct_on: [course_module_user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [course_module_user_order_by!]

    """filter the rows returned"""
    where: course_module_user_bool_exp
  ): course_module_user_aggregate!
  video_url: String
}

"""
aggregated selection of "courses_modules"
"""
type courses_modules_aggregate {
  aggregate: courses_modules_aggregate_fields
  nodes: [courses_modules!]!
}

"""
aggregate fields of "courses_modules"
"""
type courses_modules_aggregate_fields {
  avg: courses_modules_avg_fields
  count(columns: [courses_modules_select_column!], distinct: Boolean): Int!
  max: courses_modules_max_fields
  min: courses_modules_min_fields
  stddev: courses_modules_stddev_fields
  stddev_pop: courses_modules_stddev_pop_fields
  stddev_samp: courses_modules_stddev_samp_fields
  sum: courses_modules_sum_fields
  var_pop: courses_modules_var_pop_fields
  var_samp: courses_modules_var_samp_fields
  variance: courses_modules_variance_fields
}

"""
order by aggregate values of table "courses_modules"
"""
input courses_modules_aggregate_order_by {
  avg: courses_modules_avg_order_by
  count: order_by
  max: courses_modules_max_order_by
  min: courses_modules_min_order_by
  stddev: courses_modules_stddev_order_by
  stddev_pop: courses_modules_stddev_pop_order_by
  stddev_samp: courses_modules_stddev_samp_order_by
  sum: courses_modules_sum_order_by
  var_pop: courses_modules_var_pop_order_by
  var_samp: courses_modules_var_samp_order_by
  variance: courses_modules_variance_order_by
}

"""
input type for inserting array relation for remote table "courses_modules"
"""
input courses_modules_arr_rel_insert_input {
  data: [courses_modules_insert_input!]!

  """on conflict condition"""
  on_conflict: courses_modules_on_conflict
}

"""aggregate avg on columns"""
type courses_modules_avg_fields {
  length: Float
}

"""
order by avg() on columns of table "courses_modules"
"""
input courses_modules_avg_order_by {
  length: order_by
}

"""
Boolean expression to filter rows from the table "courses_modules". All fields are combined with a logical 'AND'.
"""
input courses_modules_bool_exp {
  _and: [courses_modules_bool_exp!]
  _not: courses_modules_bool_exp
  _or: [courses_modules_bool_exp!]
  course: courses_bool_exp
  course_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  length: Int_comparison_exp
  thumbnail_url: String_comparison_exp
  title: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  users: course_module_user_bool_exp
  video_url: String_comparison_exp
}

"""
unique or primary key constraints on table "courses_modules"
"""
enum courses_modules_constraint {
  """unique or primary key constraint"""
  courses_modules_pkey
}

"""
input type for incrementing numeric columns in table "courses_modules"
"""
input courses_modules_inc_input {
  length: Int
}

"""
input type for inserting data into table "courses_modules"
"""
input courses_modules_insert_input {
  course: courses_obj_rel_insert_input
  course_id: uuid
  created_at: timestamptz
  description: String
  id: uuid
  length: Int
  thumbnail_url: String
  title: String
  updated_at: timestamptz
  users: course_module_user_arr_rel_insert_input
  video_url: String
}

"""aggregate max on columns"""
type courses_modules_max_fields {
  course_id: uuid
  created_at: timestamptz
  description: String
  id: uuid
  length: Int
  thumbnail_url: String
  title: String
  updated_at: timestamptz
  video_url: String
}

"""
order by max() on columns of table "courses_modules"
"""
input courses_modules_max_order_by {
  course_id: order_by
  created_at: order_by
  description: order_by
  id: order_by
  length: order_by
  thumbnail_url: order_by
  title: order_by
  updated_at: order_by
  video_url: order_by
}

"""aggregate min on columns"""
type courses_modules_min_fields {
  course_id: uuid
  created_at: timestamptz
  description: String
  id: uuid
  length: Int
  thumbnail_url: String
  title: String
  updated_at: timestamptz
  video_url: String
}

"""
order by min() on columns of table "courses_modules"
"""
input courses_modules_min_order_by {
  course_id: order_by
  created_at: order_by
  description: order_by
  id: order_by
  length: order_by
  thumbnail_url: order_by
  title: order_by
  updated_at: order_by
  video_url: order_by
}

"""
response of any mutation on the table "courses_modules"
"""
type courses_modules_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [courses_modules!]!
}

"""
input type for inserting object relation for remote table "courses_modules"
"""
input courses_modules_obj_rel_insert_input {
  data: courses_modules_insert_input!

  """on conflict condition"""
  on_conflict: courses_modules_on_conflict
}

"""
on conflict condition type for table "courses_modules"
"""
input courses_modules_on_conflict {
  constraint: courses_modules_constraint!
  update_columns: [courses_modules_update_column!]!
  where: courses_modules_bool_exp
}

"""Ordering options when selecting data from "courses_modules"."""
input courses_modules_order_by {
  course: courses_order_by
  course_id: order_by
  created_at: order_by
  description: order_by
  id: order_by
  length: order_by
  thumbnail_url: order_by
  title: order_by
  updated_at: order_by
  users_aggregate: course_module_user_aggregate_order_by
  video_url: order_by
}

"""primary key columns input for table: courses_modules"""
input courses_modules_pk_columns_input {
  id: uuid!
}

"""
select columns of table "courses_modules"
"""
enum courses_modules_select_column {
  """column name"""
  course_id

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  length

  """column name"""
  thumbnail_url

  """column name"""
  title

  """column name"""
  updated_at

  """column name"""
  video_url
}

"""
input type for updating data in table "courses_modules"
"""
input courses_modules_set_input {
  course_id: uuid
  created_at: timestamptz
  description: String
  id: uuid
  length: Int
  thumbnail_url: String
  title: String
  updated_at: timestamptz
  video_url: String
}

"""aggregate stddev on columns"""
type courses_modules_stddev_fields {
  length: Float
}

"""
order by stddev() on columns of table "courses_modules"
"""
input courses_modules_stddev_order_by {
  length: order_by
}

"""aggregate stddev_pop on columns"""
type courses_modules_stddev_pop_fields {
  length: Float
}

"""
order by stddev_pop() on columns of table "courses_modules"
"""
input courses_modules_stddev_pop_order_by {
  length: order_by
}

"""aggregate stddev_samp on columns"""
type courses_modules_stddev_samp_fields {
  length: Float
}

"""
order by stddev_samp() on columns of table "courses_modules"
"""
input courses_modules_stddev_samp_order_by {
  length: order_by
}

"""aggregate sum on columns"""
type courses_modules_sum_fields {
  length: Int
}

"""
order by sum() on columns of table "courses_modules"
"""
input courses_modules_sum_order_by {
  length: order_by
}

"""
update columns of table "courses_modules"
"""
enum courses_modules_update_column {
  """column name"""
  course_id

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  length

  """column name"""
  thumbnail_url

  """column name"""
  title

  """column name"""
  updated_at

  """column name"""
  video_url
}

"""aggregate var_pop on columns"""
type courses_modules_var_pop_fields {
  length: Float
}

"""
order by var_pop() on columns of table "courses_modules"
"""
input courses_modules_var_pop_order_by {
  length: order_by
}

"""aggregate var_samp on columns"""
type courses_modules_var_samp_fields {
  length: Float
}

"""
order by var_samp() on columns of table "courses_modules"
"""
input courses_modules_var_samp_order_by {
  length: order_by
}

"""aggregate variance on columns"""
type courses_modules_variance_fields {
  length: Float
}

"""
order by variance() on columns of table "courses_modules"
"""
input courses_modules_variance_order_by {
  length: order_by
}

"""
response of any mutation on the table "courses"
"""
type courses_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [courses!]!
}

"""
input type for inserting object relation for remote table "courses"
"""
input courses_obj_rel_insert_input {
  data: courses_insert_input!

  """on conflict condition"""
  on_conflict: courses_on_conflict
}

"""
on conflict condition type for table "courses"
"""
input courses_on_conflict {
  constraint: courses_constraint!
  update_columns: [courses_update_column!]!
  where: courses_bool_exp
}

"""Ordering options when selecting data from "courses"."""
input courses_order_by {
  authors_aggregate: author_course_aggregate_order_by
  banner_url: order_by
  category: categories_order_by
  category_id: order_by
  created_at: order_by
  description: order_by
  difficulty: order_by
  id: order_by
  learning_outcomes_aggregate: courses_learning_outcomes_aggregate_order_by
  modules_aggregate: courses_modules_aggregate_order_by
  sector: sectors_order_by
  sector_id: order_by
  subcategory: subcategories_order_by
  subcategory_id: order_by
  title: order_by
  updated_at: order_by
  users_aggregate: course_user_aggregate_order_by
}

"""primary key columns input for table: courses"""
input courses_pk_columns_input {
  id: uuid!
}

"""
select columns of table "courses"
"""
enum courses_select_column {
  """column name"""
  banner_url

  """column name"""
  category_id

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  difficulty

  """column name"""
  id

  """column name"""
  sector_id

  """column name"""
  subcategory_id

  """column name"""
  title

  """column name"""
  updated_at
}

"""
input type for updating data in table "courses"
"""
input courses_set_input {
  banner_url: String
  category_id: uuid
  created_at: timestamptz
  description: String
  difficulty: bpchar
  id: uuid
  sector_id: uuid
  subcategory_id: uuid
  title: String
  updated_at: timestamptz
}

"""
update columns of table "courses"
"""
enum courses_update_column {
  """column name"""
  banner_url

  """column name"""
  category_id

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  difficulty

  """column name"""
  id

  """column name"""
  sector_id

  """column name"""
  subcategory_id

  """column name"""
  title

  """column name"""
  updated_at
}

type mutation_root {
  """
  delete data from the table: "author_course"
  """
  delete_author_course(
    """filter the rows which have to be deleted"""
    where: author_course_bool_exp!
  ): author_course_mutation_response

  """
  delete single row from the table: "author_course"
  """
  delete_author_course_by_pk(id: uuid!): author_course

  """
  delete data from the table: "authors"
  """
  delete_authors(
    """filter the rows which have to be deleted"""
    where: authors_bool_exp!
  ): authors_mutation_response

  """
  delete single row from the table: "authors"
  """
  delete_authors_by_pk(id: uuid!): authors

  """
  delete data from the table: "categories"
  """
  delete_categories(
    """filter the rows which have to be deleted"""
    where: categories_bool_exp!
  ): categories_mutation_response

  """
  delete single row from the table: "categories"
  """
  delete_categories_by_pk(id: uuid!): categories

  """
  delete data from the table: "course_module_user"
  """
  delete_course_module_user(
    """filter the rows which have to be deleted"""
    where: course_module_user_bool_exp!
  ): course_module_user_mutation_response

  """
  delete single row from the table: "course_module_user"
  """
  delete_course_module_user_by_pk(id: uuid!): course_module_user

  """
  delete data from the table: "course_user"
  """
  delete_course_user(
    """filter the rows which have to be deleted"""
    where: course_user_bool_exp!
  ): course_user_mutation_response

  """
  delete single row from the table: "course_user"
  """
  delete_course_user_by_pk(id: uuid!): course_user

  """
  delete data from the table: "courses"
  """
  delete_courses(
    """filter the rows which have to be deleted"""
    where: courses_bool_exp!
  ): courses_mutation_response

  """
  delete single row from the table: "courses"
  """
  delete_courses_by_pk(id: uuid!): courses

  """
  delete data from the table: "courses_learning_outcomes"
  """
  delete_courses_learning_outcomes(
    """filter the rows which have to be deleted"""
    where: courses_learning_outcomes_bool_exp!
  ): courses_learning_outcomes_mutation_response

  """
  delete single row from the table: "courses_learning_outcomes"
  """
  delete_courses_learning_outcomes_by_pk(id: uuid!): courses_learning_outcomes

  """
  delete data from the table: "courses_modules"
  """
  delete_courses_modules(
    """filter the rows which have to be deleted"""
    where: courses_modules_bool_exp!
  ): courses_modules_mutation_response

  """
  delete single row from the table: "courses_modules"
  """
  delete_courses_modules_by_pk(id: uuid!): courses_modules

  """
  delete data from the table: "organizations"
  """
  delete_organizations(
    """filter the rows which have to be deleted"""
    where: organizations_bool_exp!
  ): organizations_mutation_response

  """
  delete single row from the table: "organizations"
  """
  delete_organizations_by_pk(id: uuid!): organizations

  """
  delete data from the table: "sectors"
  """
  delete_sectors(
    """filter the rows which have to be deleted"""
    where: sectors_bool_exp!
  ): sectors_mutation_response

  """
  delete single row from the table: "sectors"
  """
  delete_sectors_by_pk(id: uuid!): sectors

  """
  delete data from the table: "subcategories"
  """
  delete_subcategories(
    """filter the rows which have to be deleted"""
    where: subcategories_bool_exp!
  ): subcategories_mutation_response

  """
  delete single row from the table: "subcategories"
  """
  delete_subcategories_by_pk(id: uuid!): subcategories

  """
  delete data from the table: "users"
  """
  delete_users(
    """filter the rows which have to be deleted"""
    where: users_bool_exp!
  ): users_mutation_response

  """
  delete single row from the table: "users"
  """
  delete_users_by_pk(id: uuid!): users

  """
  insert data into the table: "author_course"
  """
  insert_author_course(
    """the rows to be inserted"""
    objects: [author_course_insert_input!]!

    """on conflict condition"""
    on_conflict: author_course_on_conflict
  ): author_course_mutation_response

  """
  insert a single row into the table: "author_course"
  """
  insert_author_course_one(
    """the row to be inserted"""
    object: author_course_insert_input!

    """on conflict condition"""
    on_conflict: author_course_on_conflict
  ): author_course

  """
  insert data into the table: "authors"
  """
  insert_authors(
    """the rows to be inserted"""
    objects: [authors_insert_input!]!

    """on conflict condition"""
    on_conflict: authors_on_conflict
  ): authors_mutation_response

  """
  insert a single row into the table: "authors"
  """
  insert_authors_one(
    """the row to be inserted"""
    object: authors_insert_input!

    """on conflict condition"""
    on_conflict: authors_on_conflict
  ): authors

  """
  insert data into the table: "categories"
  """
  insert_categories(
    """the rows to be inserted"""
    objects: [categories_insert_input!]!

    """on conflict condition"""
    on_conflict: categories_on_conflict
  ): categories_mutation_response

  """
  insert a single row into the table: "categories"
  """
  insert_categories_one(
    """the row to be inserted"""
    object: categories_insert_input!

    """on conflict condition"""
    on_conflict: categories_on_conflict
  ): categories

  """
  insert data into the table: "course_module_user"
  """
  insert_course_module_user(
    """the rows to be inserted"""
    objects: [course_module_user_insert_input!]!

    """on conflict condition"""
    on_conflict: course_module_user_on_conflict
  ): course_module_user_mutation_response

  """
  insert a single row into the table: "course_module_user"
  """
  insert_course_module_user_one(
    """the row to be inserted"""
    object: course_module_user_insert_input!

    """on conflict condition"""
    on_conflict: course_module_user_on_conflict
  ): course_module_user

  """
  insert data into the table: "course_user"
  """
  insert_course_user(
    """the rows to be inserted"""
    objects: [course_user_insert_input!]!

    """on conflict condition"""
    on_conflict: course_user_on_conflict
  ): course_user_mutation_response

  """
  insert a single row into the table: "course_user"
  """
  insert_course_user_one(
    """the row to be inserted"""
    object: course_user_insert_input!

    """on conflict condition"""
    on_conflict: course_user_on_conflict
  ): course_user

  """
  insert data into the table: "courses"
  """
  insert_courses(
    """the rows to be inserted"""
    objects: [courses_insert_input!]!

    """on conflict condition"""
    on_conflict: courses_on_conflict
  ): courses_mutation_response

  """
  insert data into the table: "courses_learning_outcomes"
  """
  insert_courses_learning_outcomes(
    """the rows to be inserted"""
    objects: [courses_learning_outcomes_insert_input!]!

    """on conflict condition"""
    on_conflict: courses_learning_outcomes_on_conflict
  ): courses_learning_outcomes_mutation_response

  """
  insert a single row into the table: "courses_learning_outcomes"
  """
  insert_courses_learning_outcomes_one(
    """the row to be inserted"""
    object: courses_learning_outcomes_insert_input!

    """on conflict condition"""
    on_conflict: courses_learning_outcomes_on_conflict
  ): courses_learning_outcomes

  """
  insert data into the table: "courses_modules"
  """
  insert_courses_modules(
    """the rows to be inserted"""
    objects: [courses_modules_insert_input!]!

    """on conflict condition"""
    on_conflict: courses_modules_on_conflict
  ): courses_modules_mutation_response

  """
  insert a single row into the table: "courses_modules"
  """
  insert_courses_modules_one(
    """the row to be inserted"""
    object: courses_modules_insert_input!

    """on conflict condition"""
    on_conflict: courses_modules_on_conflict
  ): courses_modules

  """
  insert a single row into the table: "courses"
  """
  insert_courses_one(
    """the row to be inserted"""
    object: courses_insert_input!

    """on conflict condition"""
    on_conflict: courses_on_conflict
  ): courses

  """
  insert data into the table: "organizations"
  """
  insert_organizations(
    """the rows to be inserted"""
    objects: [organizations_insert_input!]!

    """on conflict condition"""
    on_conflict: organizations_on_conflict
  ): organizations_mutation_response

  """
  insert a single row into the table: "organizations"
  """
  insert_organizations_one(
    """the row to be inserted"""
    object: organizations_insert_input!

    """on conflict condition"""
    on_conflict: organizations_on_conflict
  ): organizations

  """
  insert data into the table: "sectors"
  """
  insert_sectors(
    """the rows to be inserted"""
    objects: [sectors_insert_input!]!

    """on conflict condition"""
    on_conflict: sectors_on_conflict
  ): sectors_mutation_response

  """
  insert a single row into the table: "sectors"
  """
  insert_sectors_one(
    """the row to be inserted"""
    object: sectors_insert_input!

    """on conflict condition"""
    on_conflict: sectors_on_conflict
  ): sectors

  """
  insert data into the table: "subcategories"
  """
  insert_subcategories(
    """the rows to be inserted"""
    objects: [subcategories_insert_input!]!

    """on conflict condition"""
    on_conflict: subcategories_on_conflict
  ): subcategories_mutation_response

  """
  insert a single row into the table: "subcategories"
  """
  insert_subcategories_one(
    """the row to be inserted"""
    object: subcategories_insert_input!

    """on conflict condition"""
    on_conflict: subcategories_on_conflict
  ): subcategories

  """
  insert data into the table: "users"
  """
  insert_users(
    """the rows to be inserted"""
    objects: [users_insert_input!]!

    """on conflict condition"""
    on_conflict: users_on_conflict
  ): users_mutation_response

  """
  insert a single row into the table: "users"
  """
  insert_users_one(
    """the row to be inserted"""
    object: users_insert_input!

    """on conflict condition"""
    on_conflict: users_on_conflict
  ): users

  """
  update data of the table: "author_course"
  """
  update_author_course(
    """sets the columns of the filtered rows to the given values"""
    _set: author_course_set_input

    """filter the rows which have to be updated"""
    where: author_course_bool_exp!
  ): author_course_mutation_response

  """
  update single row of the table: "author_course"
  """
  update_author_course_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: author_course_set_input
    pk_columns: author_course_pk_columns_input!
  ): author_course

  """
  update data of the table: "authors"
  """
  update_authors(
    """sets the columns of the filtered rows to the given values"""
    _set: authors_set_input

    """filter the rows which have to be updated"""
    where: authors_bool_exp!
  ): authors_mutation_response

  """
  update single row of the table: "authors"
  """
  update_authors_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: authors_set_input
    pk_columns: authors_pk_columns_input!
  ): authors

  """
  update data of the table: "categories"
  """
  update_categories(
    """sets the columns of the filtered rows to the given values"""
    _set: categories_set_input

    """filter the rows which have to be updated"""
    where: categories_bool_exp!
  ): categories_mutation_response

  """
  update single row of the table: "categories"
  """
  update_categories_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: categories_set_input
    pk_columns: categories_pk_columns_input!
  ): categories

  """
  update data of the table: "course_module_user"
  """
  update_course_module_user(
    """increments the numeric columns with given value of the filtered values"""
    _inc: course_module_user_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: course_module_user_set_input

    """filter the rows which have to be updated"""
    where: course_module_user_bool_exp!
  ): course_module_user_mutation_response

  """
  update single row of the table: "course_module_user"
  """
  update_course_module_user_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: course_module_user_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: course_module_user_set_input
    pk_columns: course_module_user_pk_columns_input!
  ): course_module_user

  """
  update data of the table: "course_user"
  """
  update_course_user(
    """sets the columns of the filtered rows to the given values"""
    _set: course_user_set_input

    """filter the rows which have to be updated"""
    where: course_user_bool_exp!
  ): course_user_mutation_response

  """
  update single row of the table: "course_user"
  """
  update_course_user_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: course_user_set_input
    pk_columns: course_user_pk_columns_input!
  ): course_user

  """
  update data of the table: "courses"
  """
  update_courses(
    """sets the columns of the filtered rows to the given values"""
    _set: courses_set_input

    """filter the rows which have to be updated"""
    where: courses_bool_exp!
  ): courses_mutation_response

  """
  update single row of the table: "courses"
  """
  update_courses_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: courses_set_input
    pk_columns: courses_pk_columns_input!
  ): courses

  """
  update data of the table: "courses_learning_outcomes"
  """
  update_courses_learning_outcomes(
    """sets the columns of the filtered rows to the given values"""
    _set: courses_learning_outcomes_set_input

    """filter the rows which have to be updated"""
    where: courses_learning_outcomes_bool_exp!
  ): courses_learning_outcomes_mutation_response

  """
  update single row of the table: "courses_learning_outcomes"
  """
  update_courses_learning_outcomes_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: courses_learning_outcomes_set_input
    pk_columns: courses_learning_outcomes_pk_columns_input!
  ): courses_learning_outcomes

  """
  update data of the table: "courses_modules"
  """
  update_courses_modules(
    """increments the numeric columns with given value of the filtered values"""
    _inc: courses_modules_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: courses_modules_set_input

    """filter the rows which have to be updated"""
    where: courses_modules_bool_exp!
  ): courses_modules_mutation_response

  """
  update single row of the table: "courses_modules"
  """
  update_courses_modules_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: courses_modules_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: courses_modules_set_input
    pk_columns: courses_modules_pk_columns_input!
  ): courses_modules

  """
  update data of the table: "organizations"
  """
  update_organizations(
    """sets the columns of the filtered rows to the given values"""
    _set: organizations_set_input

    """filter the rows which have to be updated"""
    where: organizations_bool_exp!
  ): organizations_mutation_response

  """
  update single row of the table: "organizations"
  """
  update_organizations_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: organizations_set_input
    pk_columns: organizations_pk_columns_input!
  ): organizations

  """
  update data of the table: "sectors"
  """
  update_sectors(
    """sets the columns of the filtered rows to the given values"""
    _set: sectors_set_input

    """filter the rows which have to be updated"""
    where: sectors_bool_exp!
  ): sectors_mutation_response

  """
  update single row of the table: "sectors"
  """
  update_sectors_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: sectors_set_input
    pk_columns: sectors_pk_columns_input!
  ): sectors

  """
  update data of the table: "subcategories"
  """
  update_subcategories(
    """sets the columns of the filtered rows to the given values"""
    _set: subcategories_set_input

    """filter the rows which have to be updated"""
    where: subcategories_bool_exp!
  ): subcategories_mutation_response

  """
  update single row of the table: "subcategories"
  """
  update_subcategories_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: subcategories_set_input
    pk_columns: subcategories_pk_columns_input!
  ): subcategories

  """
  update data of the table: "users"
  """
  update_users(
    """sets the columns of the filtered rows to the given values"""
    _set: users_set_input

    """filter the rows which have to be updated"""
    where: users_bool_exp!
  ): users_mutation_response

  """
  update single row of the table: "users"
  """
  update_users_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: users_set_input
    pk_columns: users_pk_columns_input!
  ): users
  login(input: LoginInput): AuthPayload
  register(input: RegisterInput): AuthPayload
  passwordReset(email: String!): AuthPayload
  refreshToken: String
  logout: String
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

"""
columns and relationships of "organizations"
"""
type organizations {
  created_at: timestamptz
  id: uuid!
  name: String
  updated_at: timestamptz

  """An array relationship"""
  users(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """An aggregate relationship"""
  users_aggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!
}

"""
aggregated selection of "organizations"
"""
type organizations_aggregate {
  aggregate: organizations_aggregate_fields
  nodes: [organizations!]!
}

"""
aggregate fields of "organizations"
"""
type organizations_aggregate_fields {
  count(columns: [organizations_select_column!], distinct: Boolean): Int!
  max: organizations_max_fields
  min: organizations_min_fields
}

"""
Boolean expression to filter rows from the table "organizations". All fields are combined with a logical 'AND'.
"""
input organizations_bool_exp {
  _and: [organizations_bool_exp!]
  _not: organizations_bool_exp
  _or: [organizations_bool_exp!]
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  users: users_bool_exp
}

"""
unique or primary key constraints on table "organizations"
"""
enum organizations_constraint {
  """unique or primary key constraint"""
  organizations_pkey
}

"""
input type for inserting data into table "organizations"
"""
input organizations_insert_input {
  created_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
  users: users_arr_rel_insert_input
}

"""aggregate max on columns"""
type organizations_max_fields {
  created_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type organizations_min_fields {
  created_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "organizations"
"""
type organizations_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [organizations!]!
}

"""
input type for inserting object relation for remote table "organizations"
"""
input organizations_obj_rel_insert_input {
  data: organizations_insert_input!

  """on conflict condition"""
  on_conflict: organizations_on_conflict
}

"""
on conflict condition type for table "organizations"
"""
input organizations_on_conflict {
  constraint: organizations_constraint!
  update_columns: [organizations_update_column!]!
  where: organizations_bool_exp
}

"""Ordering options when selecting data from "organizations"."""
input organizations_order_by {
  created_at: order_by
  id: order_by
  name: order_by
  updated_at: order_by
  users_aggregate: users_aggregate_order_by
}

"""primary key columns input for table: organizations"""
input organizations_pk_columns_input {
  id: uuid!
}

"""
select columns of table "organizations"
"""
enum organizations_select_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

"""
input type for updating data in table "organizations"
"""
input organizations_set_input {
  created_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
}

"""
update columns of table "organizations"
"""
enum organizations_update_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

type query_root {
  """
  fetch data from the table: "author_course"
  """
  author_course(
    """distinct select on columns"""
    distinct_on: [author_course_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [author_course_order_by!]

    """filter the rows returned"""
    where: author_course_bool_exp
  ): [author_course!]!

  """
  fetch aggregated fields from the table: "author_course"
  """
  author_course_aggregate(
    """distinct select on columns"""
    distinct_on: [author_course_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [author_course_order_by!]

    """filter the rows returned"""
    where: author_course_bool_exp
  ): author_course_aggregate!

  """fetch data from the table: "author_course" using primary key columns"""
  author_course_by_pk(id: uuid!): author_course

  """
  fetch data from the table: "authors"
  """
  authors(
    """distinct select on columns"""
    distinct_on: [authors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authors_order_by!]

    """filter the rows returned"""
    where: authors_bool_exp
  ): [authors!]!

  """
  fetch aggregated fields from the table: "authors"
  """
  authors_aggregate(
    """distinct select on columns"""
    distinct_on: [authors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authors_order_by!]

    """filter the rows returned"""
    where: authors_bool_exp
  ): authors_aggregate!

  """fetch data from the table: "authors" using primary key columns"""
  authors_by_pk(id: uuid!): authors

  """
  fetch data from the table: "categories"
  """
  categories(
    """distinct select on columns"""
    distinct_on: [categories_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [categories_order_by!]

    """filter the rows returned"""
    where: categories_bool_exp
  ): [categories!]!

  """
  fetch aggregated fields from the table: "categories"
  """
  categories_aggregate(
    """distinct select on columns"""
    distinct_on: [categories_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [categories_order_by!]

    """filter the rows returned"""
    where: categories_bool_exp
  ): categories_aggregate!

  """fetch data from the table: "categories" using primary key columns"""
  categories_by_pk(id: uuid!): categories

  """
  fetch data from the table: "course_module_user"
  """
  course_module_user(
    """distinct select on columns"""
    distinct_on: [course_module_user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [course_module_user_order_by!]

    """filter the rows returned"""
    where: course_module_user_bool_exp
  ): [course_module_user!]!

  """
  fetch aggregated fields from the table: "course_module_user"
  """
  course_module_user_aggregate(
    """distinct select on columns"""
    distinct_on: [course_module_user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [course_module_user_order_by!]

    """filter the rows returned"""
    where: course_module_user_bool_exp
  ): course_module_user_aggregate!

  """
  fetch data from the table: "course_module_user" using primary key columns
  """
  course_module_user_by_pk(id: uuid!): course_module_user

  """
  fetch data from the table: "course_user"
  """
  course_user(
    """distinct select on columns"""
    distinct_on: [course_user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [course_user_order_by!]

    """filter the rows returned"""
    where: course_user_bool_exp
  ): [course_user!]!

  """
  fetch aggregated fields from the table: "course_user"
  """
  course_user_aggregate(
    """distinct select on columns"""
    distinct_on: [course_user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [course_user_order_by!]

    """filter the rows returned"""
    where: course_user_bool_exp
  ): course_user_aggregate!

  """fetch data from the table: "course_user" using primary key columns"""
  course_user_by_pk(id: uuid!): course_user

  """An array relationship"""
  courses(
    """distinct select on columns"""
    distinct_on: [courses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [courses_order_by!]

    """filter the rows returned"""
    where: courses_bool_exp
  ): [courses!]!

  """An aggregate relationship"""
  courses_aggregate(
    """distinct select on columns"""
    distinct_on: [courses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [courses_order_by!]

    """filter the rows returned"""
    where: courses_bool_exp
  ): courses_aggregate!

  """fetch data from the table: "courses" using primary key columns"""
  courses_by_pk(id: uuid!): courses

  """
  fetch data from the table: "courses_learning_outcomes"
  """
  courses_learning_outcomes(
    """distinct select on columns"""
    distinct_on: [courses_learning_outcomes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [courses_learning_outcomes_order_by!]

    """filter the rows returned"""
    where: courses_learning_outcomes_bool_exp
  ): [courses_learning_outcomes!]!

  """
  fetch aggregated fields from the table: "courses_learning_outcomes"
  """
  courses_learning_outcomes_aggregate(
    """distinct select on columns"""
    distinct_on: [courses_learning_outcomes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [courses_learning_outcomes_order_by!]

    """filter the rows returned"""
    where: courses_learning_outcomes_bool_exp
  ): courses_learning_outcomes_aggregate!

  """
  fetch data from the table: "courses_learning_outcomes" using primary key columns
  """
  courses_learning_outcomes_by_pk(id: uuid!): courses_learning_outcomes

  """
  fetch data from the table: "courses_modules"
  """
  courses_modules(
    """distinct select on columns"""
    distinct_on: [courses_modules_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [courses_modules_order_by!]

    """filter the rows returned"""
    where: courses_modules_bool_exp
  ): [courses_modules!]!

  """
  fetch aggregated fields from the table: "courses_modules"
  """
  courses_modules_aggregate(
    """distinct select on columns"""
    distinct_on: [courses_modules_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [courses_modules_order_by!]

    """filter the rows returned"""
    where: courses_modules_bool_exp
  ): courses_modules_aggregate!

  """fetch data from the table: "courses_modules" using primary key columns"""
  courses_modules_by_pk(id: uuid!): courses_modules

  """
  fetch data from the table: "organizations"
  """
  organizations(
    """distinct select on columns"""
    distinct_on: [organizations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organizations_order_by!]

    """filter the rows returned"""
    where: organizations_bool_exp
  ): [organizations!]!

  """
  fetch aggregated fields from the table: "organizations"
  """
  organizations_aggregate(
    """distinct select on columns"""
    distinct_on: [organizations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [organizations_order_by!]

    """filter the rows returned"""
    where: organizations_bool_exp
  ): organizations_aggregate!

  """fetch data from the table: "organizations" using primary key columns"""
  organizations_by_pk(id: uuid!): organizations

  """
  fetch data from the table: "sectors"
  """
  sectors(
    """distinct select on columns"""
    distinct_on: [sectors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sectors_order_by!]

    """filter the rows returned"""
    where: sectors_bool_exp
  ): [sectors!]!

  """
  fetch aggregated fields from the table: "sectors"
  """
  sectors_aggregate(
    """distinct select on columns"""
    distinct_on: [sectors_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sectors_order_by!]

    """filter the rows returned"""
    where: sectors_bool_exp
  ): sectors_aggregate!

  """fetch data from the table: "sectors" using primary key columns"""
  sectors_by_pk(id: uuid!): sectors

  """An array relationship"""
  subcategories(
    """distinct select on columns"""
    distinct_on: [subcategories_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subcategories_order_by!]

    """filter the rows returned"""
    where: subcategories_bool_exp
  ): [subcategories!]!

  """An aggregate relationship"""
  subcategories_aggregate(
    """distinct select on columns"""
    distinct_on: [subcategories_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subcategories_order_by!]

    """filter the rows returned"""
    where: subcategories_bool_exp
  ): subcategories_aggregate!

  """fetch data from the table: "subcategories" using primary key columns"""
  subcategories_by_pk(id: uuid!): subcategories

  """An array relationship"""
  users(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """An aggregate relationship"""
  users_aggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!

  """fetch data from the table: "users" using primary key columns"""
  users_by_pk(id: uuid!): users
  hello: String
}

"""
columns and relationships of "sectors"
"""
type sectors {
  """An array relationship"""
  courses(
    """distinct select on columns"""
    distinct_on: [courses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [courses_order_by!]

    """filter the rows returned"""
    where: courses_bool_exp
  ): [courses!]!

  """An aggregate relationship"""
  courses_aggregate(
    """distinct select on columns"""
    distinct_on: [courses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [courses_order_by!]

    """filter the rows returned"""
    where: courses_bool_exp
  ): courses_aggregate!
  created_at: timestamptz!
  id: uuid!
  name: String!
  updated_at: timestamptz!
}

"""
aggregated selection of "sectors"
"""
type sectors_aggregate {
  aggregate: sectors_aggregate_fields
  nodes: [sectors!]!
}

"""
aggregate fields of "sectors"
"""
type sectors_aggregate_fields {
  count(columns: [sectors_select_column!], distinct: Boolean): Int!
  max: sectors_max_fields
  min: sectors_min_fields
}

"""
Boolean expression to filter rows from the table "sectors". All fields are combined with a logical 'AND'.
"""
input sectors_bool_exp {
  _and: [sectors_bool_exp!]
  _not: sectors_bool_exp
  _or: [sectors_bool_exp!]
  courses: courses_bool_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "sectors"
"""
enum sectors_constraint {
  """unique or primary key constraint"""
  sectors_pkey
}

"""
input type for inserting data into table "sectors"
"""
input sectors_insert_input {
  courses: courses_arr_rel_insert_input
  created_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type sectors_max_fields {
  created_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type sectors_min_fields {
  created_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "sectors"
"""
type sectors_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [sectors!]!
}

"""
input type for inserting object relation for remote table "sectors"
"""
input sectors_obj_rel_insert_input {
  data: sectors_insert_input!

  """on conflict condition"""
  on_conflict: sectors_on_conflict
}

"""
on conflict condition type for table "sectors"
"""
input sectors_on_conflict {
  constraint: sectors_constraint!
  update_columns: [sectors_update_column!]!
  where: sectors_bool_exp
}

"""Ordering options when selecting data from "sectors"."""
input sectors_order_by {
  courses_aggregate: courses_aggregate_order_by
  created_at: order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

"""primary key columns input for table: sectors"""
input sectors_pk_columns_input {
  id: uuid!
}

"""
select columns of table "sectors"
"""
enum sectors_select_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

"""
input type for updating data in table "sectors"
"""
input sectors_set_input {
  created_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
}

"""
update columns of table "sectors"
"""
enum sectors_update_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

"""
columns and relationships of "subcategories"
"""
type subcategories {
  """An object relationship"""
  category: categories!
  category_id: uuid!

  """An array relationship"""
  courses(
    """distinct select on columns"""
    distinct_on: [courses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [courses_order_by!]

    """filter the rows returned"""
    where: courses_bool_exp
  ): [courses!]!

  """An aggregate relationship"""
  courses_aggregate(
    """distinct select on columns"""
    distinct_on: [courses_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [courses_order_by!]

    """filter the rows returned"""
    where: courses_bool_exp
  ): courses_aggregate!
  created_at: timestamptz!
  id: uuid!
  name: String!
  updated_at: timestamptz!
}

"""
aggregated selection of "subcategories"
"""
type subcategories_aggregate {
  aggregate: subcategories_aggregate_fields
  nodes: [subcategories!]!
}

"""
aggregate fields of "subcategories"
"""
type subcategories_aggregate_fields {
  count(columns: [subcategories_select_column!], distinct: Boolean): Int!
  max: subcategories_max_fields
  min: subcategories_min_fields
}

"""
order by aggregate values of table "subcategories"
"""
input subcategories_aggregate_order_by {
  count: order_by
  max: subcategories_max_order_by
  min: subcategories_min_order_by
}

"""
input type for inserting array relation for remote table "subcategories"
"""
input subcategories_arr_rel_insert_input {
  data: [subcategories_insert_input!]!

  """on conflict condition"""
  on_conflict: subcategories_on_conflict
}

"""
Boolean expression to filter rows from the table "subcategories". All fields are combined with a logical 'AND'.
"""
input subcategories_bool_exp {
  _and: [subcategories_bool_exp!]
  _not: subcategories_bool_exp
  _or: [subcategories_bool_exp!]
  category: categories_bool_exp
  category_id: uuid_comparison_exp
  courses: courses_bool_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "subcategories"
"""
enum subcategories_constraint {
  """unique or primary key constraint"""
  subcategories_pkey
}

"""
input type for inserting data into table "subcategories"
"""
input subcategories_insert_input {
  category: categories_obj_rel_insert_input
  category_id: uuid
  courses: courses_arr_rel_insert_input
  created_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type subcategories_max_fields {
  category_id: uuid
  created_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "subcategories"
"""
input subcategories_max_order_by {
  category_id: order_by
  created_at: order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type subcategories_min_fields {
  category_id: uuid
  created_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "subcategories"
"""
input subcategories_min_order_by {
  category_id: order_by
  created_at: order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "subcategories"
"""
type subcategories_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [subcategories!]!
}

"""
input type for inserting object relation for remote table "subcategories"
"""
input subcategories_obj_rel_insert_input {
  data: subcategories_insert_input!

  """on conflict condition"""
  on_conflict: subcategories_on_conflict
}

"""
on conflict condition type for table "subcategories"
"""
input subcategories_on_conflict {
  constraint: subcategories_constraint!
  update_columns: [subcategories_update_column!]!
  where: subcategories_bool_exp
}

"""Ordering options when selecting data from "subcategories"."""
input subcategories_order_by {
  category: categories_order_by
  category_id: order_by
  courses_aggregate: courses_aggregate_order_by
  created_at: order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

"""primary key columns input for table: subcategories"""
input subcategories_pk_columns_input {
  id: uuid!
}

"""
select columns of table "subcategories"
"""
enum subcategories_select_column {
  """column name"""
  category_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

"""
input type for updating data in table "subcategories"
"""
input subcategories_set_input {
  category_id: uuid
  created_at: timestamptz
  id: uuid
  name: String
  updated_at: timestamptz
}

"""
update columns of table "subcategories"
"""
enum subcategories_update_column {
  """column name"""
  category_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  updated_at
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""
columns and relationships of "users"
"""
type users {
  """An array relationship"""
  courses(
    """distinct select on columns"""
    distinct_on: [course_user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [course_user_order_by!]

    """filter the rows returned"""
    where: course_user_bool_exp
  ): [course_user!]!

  """An aggregate relationship"""
  courses_aggregate(
    """distinct select on columns"""
    distinct_on: [course_user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [course_user_order_by!]

    """filter the rows returned"""
    where: course_user_bool_exp
  ): course_user_aggregate!
  created_at: timestamptz
  email: bpchar!
  id: uuid!

  """An array relationship"""
  modules(
    """distinct select on columns"""
    distinct_on: [course_module_user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [course_module_user_order_by!]

    """filter the rows returned"""
    where: course_module_user_bool_exp
  ): [course_module_user!]!

  """An aggregate relationship"""
  modules_aggregate(
    """distinct select on columns"""
    distinct_on: [course_module_user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [course_module_user_order_by!]

    """filter the rows returned"""
    where: course_module_user_bool_exp
  ): course_module_user_aggregate!

  """An object relationship"""
  organization: organizations
  organization_id: uuid
  password: String!
  role: String
  updated_at: timestamptz
}

"""
aggregated selection of "users"
"""
type users_aggregate {
  aggregate: users_aggregate_fields
  nodes: [users!]!
}

"""
aggregate fields of "users"
"""
type users_aggregate_fields {
  count(columns: [users_select_column!], distinct: Boolean): Int!
  max: users_max_fields
  min: users_min_fields
}

"""
order by aggregate values of table "users"
"""
input users_aggregate_order_by {
  count: order_by
  max: users_max_order_by
  min: users_min_order_by
}

"""
input type for inserting array relation for remote table "users"
"""
input users_arr_rel_insert_input {
  data: [users_insert_input!]!

  """on conflict condition"""
  on_conflict: users_on_conflict
}

"""
Boolean expression to filter rows from the table "users". All fields are combined with a logical 'AND'.
"""
input users_bool_exp {
  _and: [users_bool_exp!]
  _not: users_bool_exp
  _or: [users_bool_exp!]
  courses: course_user_bool_exp
  created_at: timestamptz_comparison_exp
  email: bpchar_comparison_exp
  id: uuid_comparison_exp
  modules: course_module_user_bool_exp
  organization: organizations_bool_exp
  organization_id: uuid_comparison_exp
  password: String_comparison_exp
  role: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "users"
"""
enum users_constraint {
  """unique or primary key constraint"""
  users_email_key

  """unique or primary key constraint"""
  users_pkey
}

"""
input type for inserting data into table "users"
"""
input users_insert_input {
  courses: course_user_arr_rel_insert_input
  created_at: timestamptz
  email: bpchar
  id: uuid
  modules: course_module_user_arr_rel_insert_input
  organization: organizations_obj_rel_insert_input
  organization_id: uuid
  password: String
  role: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type users_max_fields {
  created_at: timestamptz
  email: bpchar
  id: uuid
  organization_id: uuid
  password: String
  role: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "users"
"""
input users_max_order_by {
  created_at: order_by
  email: order_by
  id: order_by
  organization_id: order_by
  password: order_by
  role: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type users_min_fields {
  created_at: timestamptz
  email: bpchar
  id: uuid
  organization_id: uuid
  password: String
  role: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "users"
"""
input users_min_order_by {
  created_at: order_by
  email: order_by
  id: order_by
  organization_id: order_by
  password: order_by
  role: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "users"
"""
type users_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [users!]!
}

"""
input type for inserting object relation for remote table "users"
"""
input users_obj_rel_insert_input {
  data: users_insert_input!

  """on conflict condition"""
  on_conflict: users_on_conflict
}

"""
on conflict condition type for table "users"
"""
input users_on_conflict {
  constraint: users_constraint!
  update_columns: [users_update_column!]!
  where: users_bool_exp
}

"""Ordering options when selecting data from "users"."""
input users_order_by {
  courses_aggregate: course_user_aggregate_order_by
  created_at: order_by
  email: order_by
  id: order_by
  modules_aggregate: course_module_user_aggregate_order_by
  organization: organizations_order_by
  organization_id: order_by
  password: order_by
  role: order_by
  updated_at: order_by
}

"""primary key columns input for table: users"""
input users_pk_columns_input {
  id: uuid!
}

"""
select columns of table "users"
"""
enum users_select_column {
  """column name"""
  created_at

  """column name"""
  email

  """column name"""
  id

  """column name"""
  organization_id

  """column name"""
  password

  """column name"""
  role

  """column name"""
  updated_at
}

"""
input type for updating data in table "users"
"""
input users_set_input {
  created_at: timestamptz
  email: bpchar
  id: uuid
  organization_id: uuid
  password: String
  role: String
  updated_at: timestamptz
}

"""
update columns of table "users"
"""
enum users_update_column {
  """column name"""
  created_at

  """column name"""
  email

  """column name"""
  id

  """column name"""
  organization_id

  """column name"""
  password

  """column name"""
  role

  """column name"""
  updated_at
}

scalar uuid

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}
